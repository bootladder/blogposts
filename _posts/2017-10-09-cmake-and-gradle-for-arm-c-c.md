---
layout: post
title: CMake and Gradle for ARM C/C++
---
  
I'm trying to build my codebase in CMake or Gradle.  
Tried Gradle first.  At first glance there are way too many DSL keywords,
I have no idea what they do and connecting the dots is insane.  
It's the same frustration I get with python.  Never knowing what type anything is
and always having to look up documentation before writing a single line.
  
Now trying CMake...
  
http://derekmolloy.ie/hello-world-introductions-to-cmake/
  
I started with this CMakeLists.txt
```
cmake_minimum_required(VERSION 2.8)
project(hello)
set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/bin)
set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})
include_directories("${PROJECT_SOURCE_DIR}")
add_executable(hello ${PROJECT_SOURCE_DIR}/src/main.c)
```
  
To build,
```
cmake .
make
```
  
Wow it actually tried to compile something.  No include directories were supplied.  Let's add one.
```
include_directories(myincludedir)
```
Works.  Now there's another header that's not inside the repo.  
Let's add those.
  
```
include_directories("../samd20_cmsis_headers")
include_directories("../arm_cmsis_headers")
```

Next error, Error: no such instruction: `cpsie i'.  
I must not be compling with the arm gcc compiler.  
```
set(CMAKE_C_COMPILER arm-none-eabi-gcc)
```
  
```
arm-none-eabi-gcc: error: unrecognized command line option '-rdynamic'
```
  
Now I get this error.  Found a solution from here.  
```
https://github.com/digitalbitbox/mcu/blob/master/arm.cmake
# Avoid known bug in linux giving: 
#    arm-none-eabi-gcc: error: unrecognized command line option '-rdynamic'
set(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
```
  
For the CFLAGS I used this syntax.
```
set(CMAKE_C_FLAGS "-std=c99                      ")
string(APPEND CMAKE_C_FLAGS "-Wall                         ")
string(APPEND CMAKE_C_FLAGS "-Wextra                       ")
```
  
I used this to add directories containing source files to be compiled.
```
file(GLOB SOURCES
    "src/*.h"
    "src/*.c"
    "src/hal/*.c"
    "src/hal/*.h"
)
```
And I changed the executable to be built from those sources:
```
add_executable(myname ${SOURCES})
```
  
I noticed the output of the GNU size command shows different sizes for the
ELF output from the CMake build and the original Makefile build.
  I realized I never specified the linker script.  Let's do that.
  
Turns out I just stick it in the CMAKE_C_FLAGS , no need for a separate linker flags.
  
Added that and I get the desired output.
```
   text    data     bss     dec     hex filename     
  3352      68    2584    6004    1774 bin/debos_firmware  
```
  
Seeing that exact same output on either build is... extremely releiving.
  
# Uh, now I'm trying to build my unit test executable.
  
I got this far ...
```
file(GLOB TEST_SOURCES
    "test/*.h"
    "test/*.c"
    "test/test_runners/*.c"
    "test/test_runners/*.h"
    "mock/*.c"
    "../Unity/src/*.c"
    "src/*.c"
    "src/hal/*.c"
)
```
  
First issue I have to deal with:  
Multiple Definition error from the linker.  
As you see, I included the test/ directory and src/.
Inside test there are some mocked objects.  The names collide with the ones from source.  
  
A solution I've learned from various books is to compile the source into a library.
When linking the test executable, the library will only be searched when the
symbol is not found in the test objects.  
This hackish technique creates a priority of sorts, for names.  Test names first, production names second.  

  
Now how do I do this with CMake?  Reimplement that above logic?  
My guess is Yes, because CMake just wraps make and it is make and gcc that are complaining
about not finding the symbols.  

# Create a static library of the application code and link it to the test exe  
```
add_library(applib_debos_firmware STATIC ${SOURCES})
add_executable(test_debos_firmware ${TEST_SOURCES})
target_link_libraries(test_debos_firmware applib_debos_firmware )
```
  
First, the above CMakeLists.txt is inside the test/ directory.  
So I have CMakeLists.txt inside both src/ and test/.  
To build, I go inside a directory and run cmake, and the Makefile is generated in the directory.  
Since the Makefile is now autogenerated, I now have it in .gitignore.    
  
The ${SOURCES} is a collection of source inside src/ , but does not include HAL.  
HAL code is generally not compilable on host.  
If there is a high level HAL like a UART driver then I'll put that in src/ not hal/.
  

# So far this is good.  Next I want the dependencies pulled in automatically.
  
This particular project needs libraries:  unit test library, 
target specific headers repositories. 
  
Unit Test library is public URL, target specific headers are public git URL.  
```  
ExternalProject_Add(samd20_headers
    GIT_REPOSITORY "https://bitbucket.org/bootladder/samd20_cmsis_headers"
    BUILD_COMMAND ""
    UPDATE_COMMAND ""
    CONFIGURE_COMMAND ""
    INSTALL_COMMAND ""
)
```
  
This worked to get the repo downloaded.  The following showed up in my ls:
```
drwxr-xr-x 4 steve supervisorusers 4.0K Oct 10 15:50 samd20_headers-prefix/
```
What is this prefix business...  let's put in a prefix.  
  
If I put in a 
```
PREFIX "hello"
```
Then the repo is cloned, named hello.  what??  
Apparently it's supposed to be this:
```
PREFIX "samd20_headers"
```
Why do I have to explicitly type the same name...
  
# Anyway, next problem is, the include path is no longer the same.
  
I need to tell CMake to add include directories to the compiler command.  
  
# Oh, prefix is for where the external project is installed.  Doesn't have to be inside this project
  
# Moving on to the test build, auto downloading the Unity test framework
  
This one was tricky because it doesn't provide a build script.
It is intended for the library consumer to build the source.  
Also, the source is not in the top directory of the repo.
  
I solved it with a kludge, don't like it:
  
First, this is how I added compiler include directories.  
Using install_dir as a global variable here...
```
ExternalProject_Get_Property(samd20_headers install_dir)
include_directories(${install_dir}/src/samd20_headers/)
ExternalProject_Get_Property(arm_cmsis_headers install_dir)
include_directories(${install_dir}/src/arm_cmsis_headers/)
ExternalProject_Get_Property(unity install_dir)
include_directories(${install_dir}/src/unity/src/)
include_directories(${install_dir}/src/unity/extras/fixture/src/)
```
  
Notice at the end, for unity, there are 2 calls to include_directories().
I guess it's ok, it's explicit and still relative to the ${install_dir}.  
  
Later, in my list of source files, there's another kludge.
```
file(GLOB TEST_SOURCES
    "*.h"
    "*.c"
    "hal/*.c"
    "test_runners/*.c"
    "test_runners/*.h"
    "../../Unity/extras/fixture/src/*.c"
    "../mock/*.c"
    "../../Unity/src/*.c"
    "${install_dir}/src/unity/src/*"
    "${install_dir}/src/unity/extras/fixture/src/*"
)
```
  
But same, I guess it's OK, because the list is explicit and also relative to ${install_dir}.  
So every time this project is cloned and built it'll work.  
One issue is the name install_dir is only valid when install_dir was just written to with the correct contents.  

  
# Uhhh, a similar issue... Build doesn't work first time, works second time?
  
What's happening here...
  
Same thing as before.  The Unity git repo was cloned, and then
Make is supposed to compile the source as part of the build.  
But Make can't find them.  
In this case, Make did not include those sources in the list of source files to be compiled.  
Make said "Scanning dependencies of..." and then compiled the sources, but the Unity sources weren't.  
All I have to do to get the build to succeed next time is:
```
touch CMakeLists.txt
make
```
And it works; this time, it scans the dependencies, finds the Unity sources and builds them.  
  
# I guess I'm not supposed to try to do this?
  
Why should I build the source ?  That means I have to know how to build it.  
Any changes to that repo will break my build and everyone else who does it this way.  

What's the alternative?  They can't precompile unless they only supported a couple targets.  
They could include a Makefile or CMakeLists.txt.  CMake would work I guess but not Make.  
  
# Let's follow this one:  http://www.throwtheswitch.org/build/cmake  
  
Since it is literally what I'm trying to do.    
  
# Eh, let's get Ceedling working first.
  
Currently I had handwritten Unity tests.  
Ceedling does it a bit different.  
Each test.c file is linked into a test app and executed.  
It uses its own build system so anything that was in Make or CMake before
is invalid.  
This means the linker and header dependencies on the production source.  
  
To get the ceedling tests to work you have to put #include statements
in the tests, which makes Ceedling pull in source files.  
Other than that seems OK.
  
# Problem is you need a ruby and ceedling installation.  
  


